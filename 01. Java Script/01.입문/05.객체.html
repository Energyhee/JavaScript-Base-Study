<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8">
		<title>Java Script - 01.입문 - 05.객체</title>
	</head>
	<body>

    </body>
    <script>
        const log = console.log;
      

		// [객체] : 변수 또는 상수를 사용 할때 하나의 이름에 여러 종류의 값을 넣을 수 있게 해준다.
        const myPet = {
            // key : value
            name : '흰둥이',
            age : 2
        }
        log(`이름 : ${myPet.name} / 나이 : ${myPet.age} 살`);	// 이름 : 흰둥이 / 나이 : 2 살
        
        
        // ● 함수에서 객체를 파라미터(매개변수)로 받기
		const ironMan = {
            name : '토니 스타크',
            actor : '로버트 다우니 주니어',
            alias : '아이언맨'
        }
        const captain = {
            name : '스티븐 로저스',
            actor : '크리스 에반스',
            alias : '캡틴 아메리카'
        }

        print = (hero) => {				
            return log(`안녕하세요. 저는 ${ironMan.alias}(${ironMan.name})역을 맡은 ${ironMan.actor} 입니다.`);
        }
        print(ironMan);		// 안녕하세요. 저는 아이언맨(토니 스타크)역을 맡은 로버트 다우니 주니어 입니다.

        
        // ● 객체 구조 분해 라고도 불린다.
		// print 함수 내 파라미터(매개변수)로 받아온 hero 내부 값을 조회할 때마다 hero. 를 입력하는데, 
		// 이를 객체 비구조화 할당 문법을 이용하여 코드를 더 간결하게 작성 가능.
        print02 = (hero) => {
            const { name, alias, actor } = hero;
            return log(`안녕하세요!! 저는 ${alias}(${name})역을 맡은 ${actor} 입니다.`);
        }
        print02(captain);	// 안녕하세요!!! 저는 캡틴 아메리카(스티븐 로저스)역을 맡은 크리스 에반스 입니다.
        

        // ● 파라미터(매개변수) 단계에서 값을 받아올 때부터 객체 비구조화 할당
        print03 = ({name, alias, actor} = hero) => {
            return log(`안녕하세요~ 저는 ${alias}(${name})역을 맡은 ${actor} 입니다.`);
        }
        print03(ironMan);	// 안녕하세요~~ 저는 아이언맨(토니 스타크)역을 맡은 로버트 다우니 주니어 입니다.

        
        // ● 객체 안에 함수 넣기
        const dog = {
            name : '흰둥이',
            sound : '왈!왈!왈!',
            /*
                객체 안에 함수를 넣을 때 화살표 함수(=>)는 에러가 뜬다. 
                function 으로 선언 할 때는 this가 자신이 속한 객체를 가르키지만, 화살표 함수(=>)는 this를 알 수 없다.
                여기서 this란 내가 속해 있는 객체를 바라봐야 하며, this.sound 또는 this.name에 접근하기 위함이다.
                속해있는 객체에 접근 할 필요가 없다면 화살표 함수 사용 가능.
                say : () => { // ERROR
            */
            // 함수를 선언 할 때는 함수명(이름)이 없어도 된다.
            // say : function talk(){
            say : function(){
                // 함수의 this는 자신이 속해있는 객체를 가르킨다.
                log(this.sound); // dog.sound(왈!왈!왈!);
            }
        }
        dog.say(); // 왈!왈!왈!

        
        // ● Getter 와 Setter 함수
        const testGetSet = {
            _a : 1,
            _b : 2,
            total : 3,
            clculate(){
                log('clculate 메서드가 실행 됩니다');
                this.total = this._a + this._b;
            },
            // 획득자 getter 메서드 : 객체 리터럴 안에서 get으로 표현
            // getter 메서드는 obj.propName을 사용해 프로퍼티를 읽으려고 할 때 실행, 프로퍼티로 사용 가능
            get get_a(){
                return this._a;
            },
            get get_b(){
                return this._b;
            },
            // 설정자 setter 메서드 : 객체 리터럴 안에서 set으로 표현
            // setter 메서드는 obj.propName = value으로 프로퍼티에 값을 할당하려 할 때 실행, 프로퍼티로 사용 가능
            set set_a(val){
                cLog('a의 값이 ' + val + '로 변경됩니다.');
                this._a = val;
                this.clculate();
            },
            set set_b(val){
                cLog('b의 값이 ' + val + '로 변경됩니다.');
                this._b = val;
                this.clculate();
            }
        }
        
        // 프로퍼티로 사용가능
        cLog('sum : ' + testGetSet.sum); // 3
        cLog('get_a : ' + testGetSet.get_a); // 1
        cLog('get_b : ' + testGetSet.get_b); // 2
        testGetSet.set_a = 10;
        cLog('total : ' + testGetSet.total); // 12
        testGetSet.set_b = 20;
        cLog('total : ' + testGetSet.total); // 30
        
        
        cLog(
            '%c ○ [6-2. 객체 - getter / setter] 개념 공부 추가 * ================ ',
            'width: 900px; padding: 8px 16px; background-color: #fff; color: #000;'
        );
        
        // 예제 01
        class Person{  
            // constructor 함수란 객체의 초기 값을 지정하기 위해 객체가 생성될 때 실행되기로 약속된 함수
            // constructor 함수를 이용하여 객체의 초기 값을 설정 할 수 있으며, Java Script는 개체를 생성할때 자동으로 constructor함수를 자동으로 호출한다.
            // console.log 를 이용하여 Object.prototype을 보면 값으로 린턴된 객체에는 constructor라는 속성이 들어있다. 이는 서로가 서로의 정보를 가지고 있다.
            constructor(name, age){
                this._name = name;
                this._age = age;
            }
            get GetName(){
                return `이름 : ${this._name.toUpperCase()}`;
            }
            set SetName(newName){
                if (newName) this._name = newName;
            }
            get GetAge(){
                return `나이 : ${this._age} 살`;
            }
            set SetAge(newAge){
                if (newAge) this._age = newAge;
            }
        }
        
        let human = new Person('john', 10);
        cLog(`${human.GetName} / ${human.GetAge}`); // JOHN : 10
        human.SetName = 'park';
        human.SetAge = 20;
        cLog(`${human.GetName} / ${human.GetAge}`); // PARK : 20
        human.SetName = 'han';
        human.SetAge = 31;
        cLog(`${human.GetName} / ${human.GetAge}`); // HAN : 31
        
        // 예제 02
        class Time{
            constructor(start, end){
                this._start = start;
                this._end = end;
                this._duration = end - start;
            }
            set SetNewTime(newStart){
                if (newStart || newStart === 0){
                    this._start = newStart;
                    this._duration = this._end - this._start;
                }
            }
            get GetDuration(){
                return this._duration = this._end - this._start;
            }
        }
        
        let time = new Time(10, 40); // 시작시간, 종료시간
        cLog('지속시간초기 : ' + time.GetDuration); // 30 (지속시간)
        time.SetNewTime = 0;
        cLog('지속시간수정 : ' + time.GetDuration); // 40 (지속시간)
    </script>
</html>