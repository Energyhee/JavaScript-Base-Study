<!DOCTYPE html>
<html lang="ko">
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="description" content="test">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<!-- <link rel="shortcut icon" href="/favicon.ico">
		<link rel="apple-touch-icon" href="/apple-touch-icon.png"> -->
		<title>Java Script - 01.입문 - 01.변수</title>
        <script src="https://code.jquery.com/jquery-3.6.3.min.js" integrity="sha256-pvPw+upLPUjgMXY0G+8O0xUf+/Im1MZjXxxgOcBQBXU=" crossorigin="anonymous"></script>
	</head>
	<body></body>
    <script>
        const cLog = (obj, style) => {
        if(style){
            console.log(obj, style);
        }else{
            console.log(obj);
        }
        };
         
        cLog(
            '%c ○ [0. var 과 let, const 차이점] ============================ ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* [0. var 과 let, const 차이점] */
        // ver 과 let의 큰 차이점은 var은 값으 바뀌거나 선언을 하는데 있어 제한이 없다.
        // IE10 이하 버전에서는 let, const를 사용할 수 없어 babel과 같은 도구로 구형 브라우저에서도 돌아갈 수 있게끔 변환작업 진행
        // 구형 브라우저 호환을 해야한다면, var을 사용하게 될 수도 있다.
        // var a = 1;
        // var a = 2;
        // a = 3;
        // cLog('a : ' + a);     // 3
        
        // let은 같은 블럭 내에서 같은 이름으로 선언은 불가, 값 변경 가능
        // let b = 1;
        // let b = 2;                   // error
        
        // const는 같은 블럭 내에서 같은 이름으로 선언 불가, 값 변경 불가
        // const c = 1;
        // const c = 1;                 // error
        // c = 2;
        
        cLog(
            '%c ○ [0. 변수와 상수 및 선언] ================================== ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* [0. 변수와 상수 및 선언] */
        let value = 1;
        cLog('value :: ' + value); // 1
        
        cLog(
            '%c ○ [1. 변수] ================================================ ', 
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* [1. 변수] */
        // 바뀔 수 있는 값을 말한다.
        let value2 = 1;
        cLog('let value2 :: ' + value2); // 1
        value2 = 2;
        cLog('value2 :: ' + value2); // 2
        
        // 변수를 선언 할 때 주의 점은 같은 이름으로 선언 할 수 없다.
        // 단, 다른 블럭 범위 내에서는 가능하다.
        // let value3 = 1;
        // let value3 = 2;    // ERROR
        
        cLog(
            '%c ○ [2. 상수] ================================================ ', 
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* [2. 상수] */
        // 한번 선언하고 값이 바뀌지 않는 값을 말한다.
        // 다른 코드블럭에서는 같은 명으로 선언 가능
        // const a = 1;
        // a = 2;             // ERROR
        cLog('const a = 1 선언 후 a = 2 값 초기화 또는 대입 할 경우 ERROR');
        
        // 상수를 선언 할 때 주의 점은 같은 이름으로 선언 할 수 없다.
        // const a = 1;
        // const a = 2;       // ERROR
        cLog('const a = 1 선언 후 새로 const a = 2 선언 할 경우 ERROR');
        
        cLog(
            '%c ○ [3. 데이터 타입] * ======================================== ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* [3. 데이터 타입] */
        
        let type01 = 1;
        cLog('type01 :: ' + type01 + ' / ' + typeof type01); // 1 'number'
        let type02 = 'text';
        cLog('type02 :: ' + type02 + ' / ' + typeof type02); // text 'string'
        let type03 = 1 + '1';
        cLog('type03 :: ' + type03 + ' / ' + typeof type03); // 11 'string'
        let type04 = true;
        cLog('type04 :: ' + type04 + ' / ' + typeof type04); // true 'boolean'
        let type05 = false;
        cLog('type05 :: ' + type05 + ' / ' + typeof type05); // false 'boolean'
        // null은 '의도적'으로 빈 값을 할당한 상태(빈 객체), 자료형이 있는 상태
        let type06 = null;
        cLog('type06 :: ' + type06 + ' / ' + typeof type06); // null 'object'
        // undefined은 원시값으로 값을 할당하지 않았을 때 자동 할당, 자료형이 없는 상태
        let type07;
        cLog('type07 :: ' + type07 + ' / ' + typeof type07); // undefined 'undefined'
        
        cLog(
            '%c ○ [4. 연산자] * ============================================= ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* [4. 연산자] */
        
        let example = 1; // 변수 선언
        example = 2; // 변수 초기화
        
        // ● 산술 연산자 +, -, *, /
        let calculation = 1 + 2 / 2;
        cLog('calculation ::' + calculation); // 2 'number'
        let plus = 1;
        let plusType1 = plus++;
        // 연산자가 뒤에 붙을 경우 직전 값을 반환한다.
        cLog('plus++ :: ' + plusType1); // 1 'number'
        cLog('plus++ cont :: ' + plus); // 2
        let plusType2 = ++plus;
        // 연산자가 앞에 붙을 경우 이후 값을 반환한다.
        cLog('++plus :: ' + plusType2); // 3 'number'
        cLog('plus-- cont :: ' + plus);
        
        // ● 대입 연산자
        let number = 2;
        number = number + 2;
        // 아래와 같이 작성도 가능하다.
        // let number = 2;
        // number += 2;
        // 다른 연산도 가능하다.
        // number += 2;
        // number -= 2;
        // number *= 2;
        // number /= 2;
        cLog('number :: ' + number); // 4 'number'
        
        // ● 논리 연산자 : 논리 연산자는 boolean(불리언) 타입을 위한 연산자 이다
        // ! : NOT
        // && : AND
        // || : OR
        
        // console.log(!undefined); true
        // console.log(!null); true
        // console.log(!0); true
        // console.log(!''); true
        // console.log(!NaN); true
        
        // !(NOT) 연산자는 반대 상태로 변경해준다.
        const state01 = !true;
        cLog('!true :: ' + state01); // false;
        const state02 = !false;
        cLog('!false :: ' + state02); // true;
        
        // &&(AND) 연산자는 양쪽의 값이 둘다 true 일 때만 true
        const ab = true && true;
        cLog('true && true :: ' + ab); // true
        
        // ||(OR) 연산자는 양쪽의 값 중 어느 하나라도 맞을 경우 true, 둘 다 false 일 때 false
        const abc = false || true;
        cLog('false || true :: ' + abc); // true
        
        // 논리 연산자 연산 순서는 !(NOT) > &&(AND) -> ||(OR) 순
        const abcd = !((true && false) || (true && false) || !false);
        // !((true && false) || (true && false) || true); NOT 연산자 처리
        // !(false || false || true); AND 연산자 처리
        // !true; 마지막 true 및 NOT 연산자로 인해 false
        cLog('!((true && false) || (true && false) || !false) :: ' + abcd); // false
        
        // 비교 연산자
        // 비교 연사자는 되도록 등호 세개(===)를 쓸 것 그래야 값의 타입까지 상세 비교를 함으로, 실수 유발이 적어진다.
        const left01 = 1;
        const right01 = 1;
        cLog('1 === 1 :: ' + (left01 === right01)); // true
        
        const left02 = 1; // number
        const right02 = '1'; // string
        // 등호를 세개만 썼을 경우 해당 값의 type까지 검사한다
        cLog('1 === "1" :: ' + (left02 === right02)); // false
        
        const left03 = 1; // number
        const right03 = '1'; // string
        // 등호를 두개만 썼을 경우 해당 값의 type까지 검사를 하지 않는다.
        cLog('1 == "1" :: ' + (left03 == right03)); // true
        
        const left04 = 0; // number
        const right04 = false; // object
        // 0과 false는 같은 값으로 간주된다.
        cLog('0 == false :: ' + (left04 == right04)); // true
        
        const left05 = null; // number
        const right05 = undefined; // object
        // 0과 false는 같은 값으로 간주된다.
        cLog('null == undefined :: ' + (left05 == right05)); // true
        
        // 크고 작음 (부등호)
        const num01 = 10;
        const num02 = 20;
        const num03 = 20;
        
        cLog('10 < 20 : ' + (num01 < num02)); // true
        cLog('10 > 20 : ' + (num01 > num02)); // false
        cLog('10 <= 20 : ' + (num01 <= num02)); // true
        cLog('10 >= 20 : ' + (num01 >= num02)); // false
        cLog('20 >= 20 : ' + (num02 >= num02)); // true
        cLog('20 < 20 : ' + (num02 < num02)); // false
        
        // 연사자를 이용하여 문자열(string) 합치기도 가능
        const text01 = 'Han';
        const text02 = 'ChangHee';
        
        cLog(text01 + text02);
        cLog(text02 + text01);
        
        cLog(
            '%c ○ [4. 조건문] * ============================================= ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* [4. 조건문] */
        
        // ● if 문
        const ifNum01 = 1;
        const ifNum02 = 10;
        const ifPlus = 9;
        if(ifNum01 + 9 === ifNum02){
            cLog('ifNum01(' + ifNum01 + ') + ' + ifPlus + ' 와 ifNum02(' + ifNum02 + ')이 같습니다.');
        }
        
        // const 다른 코드블럭 내 선언
        const ifCodeBlock = 1;
        if (true){
            const ifCodeBlock = 2;
            cLog('if 코드블락 내 새로 선언 된 const ifCodeBlock는 ' + ifCodeBlock + '입니다.');
        }
        cLog('if 코드블락 외 처음 선언 되어 있는 const ifCodeBlock는 ' + ifCodeBlock + '입니다.');
        
        // ● else
        const ifCodeBlock02 = 10;
        if(ifCodeBlock02 > 10){
            cLog('const ifCodeBlock02(' + ifCodeBlock02 + ')이 10보다 클 경우.');
        }else{
            cLog('const ifCodeBlock02(' + ifCodeBlock02 + ')이 10보다 작거나 같을 경우.');
        }
        
        // ● else if
        const ifCodeBlock03 = 3;
        if(ifCodeBlock03 === 1){
            cLog('const ifCodeBlock03(' + ifCodeBlock03 + ')이 1일때');
        }else if(ifCodeBlock03 === 2){
            cLog('const ifCodeBlock03(' + ifCodeBlock03 + ')이 2일때');
        }else{
            cLog('const ifCodeBlock03(' + ifCodeBlock03 + ')이 1과 2 둘다 아닐때');
        }
        
        // ● switch/cass 문 : break 를 걸어주지 않을 경우 다음 case까지 읽어들인다.
        const firstName = 'han';
        switch (firstName) {
            case 'han':
                cLog('성이 ' + firstName + '씨 입니다.');
                break;
            case 'kim':
                cLog('성이 ' + firstName + '씨 입니다.');
                break;
            default:
                // default는 기본 값, case에 맞는 값이 없을 경우 기본으로 노출
                cLog('성을 알 수 없습니다.');
        }
        
        cLog(
            '%c ○ [5. 함수] * =============================================== ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* [5. 함수] */
        // ● 하나의 명령으로 실행 할 수 있게 해주는 기능
        
        // 함수 생성 예저 01
        function plusNum(a, b){ // plusNum이라는 함수를 만들고 파라미터(매개변수)로 a,b 에 대한 값을 받아 온다
            return a + b; // 받아온 a,b 값을 대입하여 더하고 값을 반환시킨다.
            // return 하게 될 경우 함수가 끝난다. 아래의 코드들은 호출이 안된다.
            cLog('plusNum 실행'); // 실행 안됌
        }
        cLog(plusNum(2, 4));  // 6
        
        // 함수 생성 예제 02
        function helloName(name){
            // 문자열을 조합하기 위해 + 연산자를 사용하지만, ES6의 Template Lireral 문법을 사용하여 좀 더 편하게 작성 가능
            // 브라우저 버전에 따라 지원하는 Java Script 버전이 다르므로 보통 Babel을 사용하여 최신버전의 Java Script가 구버전 형태로 변환작업을 한다.
            return cLog('Hello, ' + name);
        }
        helloName('changhee');
        
        // 함수 생성 예저2 (ES6의 Template Lireral)
        function helloName02(name){
            // 따옴표가 대신 grave(그레이브) 사용
            return cLog(`Hello, ${name}`);
        }
        helloName02('HanChangHee');
        
        // 함수 생성 예제 03
        function getGrade(score){
            if (score === 100){
                return 'A';
            }else if(score >= 80){
                return 'B';
            }else if(score >= 60){
                return 'C';
            }else{
                return 'D';
            }
        };
        cLog(getGrade(99)); // B
        
        // ● 화살표 함수
        // 함수를 선언하는 방식 중 화살표 함수(=>) 문법을 사용하는 방법도 있다.
        // 화살표 함수(=>)와 function 함수의 차이점은 가르키는 this가 서로 다르다. 
        
        const addPlusNum = (a, b) => {
            // function 대신 화살표 함수(=>) 사용
            // 좌측엔 파라미터(매개변수), 우측엔 코드블럭 시작
            return a + b;
        }
        cLog(addPlusNum(10, 20)); // 30
        
        // 코드블럭 내부에서 바로 return 할 경우 더 간략히 작성 가능
        const addPlusNum02 = (a, b) => a + b;
        cLog(addPlusNum02(20, 20)); // 40
        
        // 화살표 함수(=>) 예제
        const getGrade02 = (score) => {
            if (score === 100){
                return 'A';
            }else if(score >= 80){
                return 'B';
            }else if(score >= 60){
                return 'C';
            }else{
                return 'D';
            }
        };
        cLog(getGrade02(100)); // A
        
        cLog(
            '%c ○ [6. 객체] * =============================================== ',
            'width: 900px; padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* [6. 객체] */
        // ● 변수 또는 상수를 사용 할때 하나의 이름에 여러 종류의 값을 넣을 수 있게 해준다.
        
        const myPet = {
            // key : value
            name : '흰둥이',
            age : 2
        }
        cLog(`이름 : ${myPet.name} / 나이 : ${myPet.age} 살`) // 이름 : 흰둥이 / 나이 : 2 살
        
        const ironMan = {
            name : '토니 스타크',
            actor : '로버트 다우니 주니어',
            alias : '아이언맨'
        }
        const captain = {
            name : '스티븐 로저스',
            actor : '크리스 에반스',
            alias : '캡틴 아메리카'
        }
        
        cLog(ironMan);
        
        // ● 함수에서 객체를 파라미터(매개변수)로 받기
        print = (hero) => {
            /* 
                print() 함수에 ironMan 이라는 객체를 넘겨주고 hero라는 파라미터(매개변수)로 받는다.
                print 함수 내 파라미터(매개변수)로 받아온 hero 내부 값을 조회할 때마다 hero. 를 입력하는데, 
                이를 객체 비구조화 할당 문법을 이용하여 코드를 더 간결하게 작성 가능.
                다음 함수 참조.
            */
            return cLog(`안녕하세요. 저는 ${ironMan.alias}(${ironMan.name})역을 맡은 ${ironMan.actor} 입니다.`);
        }
        print(ironMan);
        
        // 객체 구조 분해 라고도 불린다.
        print02 = (hero) => {
            /* 
                밑의 코드가 객체에서 값들을 추출해서 새로운 상수로 선언
                더 나아가 파라미터(매개변수) 단계에서 값을 받아올 때부터 객체 비구조화 할당 가능.
                다음 함수 참조.
            */
            const { name, alias, actor } = hero;
            return cLog(`안녕하세요!!! 저는 ${alias}(${name})역을 맡은 ${actor} 입니다.`);
        }
        print02(captain);
        
        // ● 파라미터(매개변수) 단계에서 값을 받아올 때부터 객체 비구조화 할당
        print03 = ({name, alias, actor} = hero) => {
            return cLog(`안녕하세요~~ 저는 ${alias}(${name})역을 맡은 ${actor} 입니다.`);
        }
        print03(ironMan);
        
        // ● 객체 안에 함수 넣기
        const dog = {
            name : '흰둥이',
            sound : '왈!왈!왈!',
            /*
                객체 안에 함수를 넣을 때 화살표 함수(=>)는 에러가 뜬다. 
                function 으로 선언 할 때는 this가 자신이 속한 객체를 가르키지만, 화살표 함수(=>)는 this를 알 수 없다.
                여기서 this란 내가 속해 있는 객체를 바라봐야 하며, this.sound 또는 this.name에 접근하기 위함이다.
                속해있는 객체에 접근 할 필요가 없다면 화살표 함수 사용 가능.
                say : () => { // ERROR
            */
            // 함수를 선언 할 때는 함수명(이름)이 없어도 된다.
            // say : function talk(){
            say : function(){
                // 함수의 this는 자신이 속해있는 객체를 가르킨다.
                cLog(this.sound); // dog.sound(왈!왈!왈!);
            }
        }
        
        dog.say(); // 왈!왈!왈!
        
        // ● Getter 와 Setter 함수
        const testGetSet = {
            _a : 1,
            _b : 2,
            total : 3,
            clculate(){
                cLog('clculate 메서드가 실행 됩니다');
                this.total = this._a + this._b;
            },
            // 획득자 getter 메서드 : 객체 리터럴 안에서 get으로 표현
            // getter 메서드는 obj.propName을 사용해 프로퍼티를 읽으려고 할 때 실행, 프로퍼티로 사용 가능
            get get_a(){
                return this._a;
            },
            get get_b(){
                return this._b;
            },
            // 설정자 setter 메서드 : 객체 리터럴 안에서 set으로 표현
            // setter 메서드는 obj.propName = value으로 프로퍼티에 값을 할당하려 할 때 실행, 프로퍼티로 사용 가능
            set set_a(val){
                cLog('a의 값이 ' + val + '로 변경됩니다.');
                this._a = val;
                this.clculate();
            },
            set set_b(val){
                cLog('b의 값이 ' + val + '로 변경됩니다.');
                this._b = val;
                this.clculate();
            }
        }
        
        // 프로퍼티로 사용가능
        cLog('sum : ' + testGetSet.sum); // 3
        cLog('get_a : ' + testGetSet.get_a); // 1
        cLog('get_b : ' + testGetSet.get_b); // 2
        testGetSet.set_a = 10;
        cLog('total : ' + testGetSet.total); // 12
        testGetSet.set_b = 20;
        cLog('total : ' + testGetSet.total); // 30
        
        
        cLog(
            '%c ○ [6-2. 객체 - getter / setter] 개념 공부 추가 * ================ ',
            'width: 900px; padding: 8px 16px; background-color: #fff; color: #000;'
        );
        
        // 예제 01
        class Person{  
            // constructor 함수란 객체의 초기 값을 지정하기 위해 객체가 생성될 때 실행되기로 약속된 함수
            // constructor 함수를 이용하여 객체의 초기 값을 설정 할 수 있으며, Java Script는 개체를 생성할때 자동으로 constructor함수를 자동으로 호출한다.
            // console.log 를 이용하여 Object.prototype을 보면 값으로 린턴된 객체에는 constructor라는 속성이 들어있다. 이는 서로가 서로의 정보를 가지고 있다.
            constructor(name, age){
                this._name = name;
                this._age = age;
            }
            get GetName(){
                return `이름 : ${this._name.toUpperCase()}`;
            }
            set SetName(newName){
                if (newName) this._name = newName;
            }
            get GetAge(){
                return `나이 : ${this._age} 살`;
            }
            set SetAge(newAge){
                if (newAge) this._age = newAge;
            }
        }
        
        let human = new Person('john', 10);
        cLog(`${human.GetName} / ${human.GetAge}`); // JOHN : 10
        human.SetName = 'park';
        human.SetAge = 20;
        cLog(`${human.GetName} / ${human.GetAge}`); // PARK : 20
        human.SetName = 'han';
        human.SetAge = 31;
        cLog(`${human.GetName} / ${human.GetAge}`); // HAN : 31
        
        // 예제 02
        class Time{
            constructor(start, end){
                this._start = start;
                this._end = end;
                this._duration = end - start;
            }
            set SetNewTime(newStart){
                if (newStart || newStart === 0){
                    this._start = newStart;
                    this._duration = this._end - this._start;
                }
            }
            get GetDuration(){
                return this._duration = this._end - this._start;
            }
        }
        
        let time = new Time(10, 40); // 시작시간, 종료시간
        cLog('지속시간초기 : ' + time.GetDuration); // 30 (지속시간)
        time.SetNewTime = 0;
        cLog('지속시간수정 : ' + time.GetDuration); // 40 (지속시간)
        
        cLog(
            '%c ○ [7. 배열] * =============================================== ',
            'width: 900px; padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* [7. 배열] */
        // ● 이전에 배운 객체의 경우 변수 혹은 상수, 여러가지 정보를 담기 위함이였다면 배열은 여러 항목이 들어있는 리스트
        let array01 = [1,2,3,4];
        cLog(array01[0]); // 1
        
        let array02 = [
            { name : '강아지' },
            { name : '고양이' }
        ];
        cLog(array02[0]); // {name : '강아지'}
        cLog(array02[0].name); // 강아지 
        
        // ● push를 이용한 배열 추가
        let array03 = [
            { name : '강아지' },
            { name : '고양이' }
        ];
        
        array03.push({
            name : '코끼리'
        });
        cLog(array03); // {name: '강아지'}, {name: '고양이'}, {name: '코끼리'}
        
        // ● length를 이용한 배열의 크기
        cLog(array03.length); // 3
        
        cLog(
            '%c ○ [8. 반복문] * ============================================= ',
            'width: 900px; padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* [8. 반복문] */
        // ● 반복문은 특정 작업을 반복적으로 사용할 수 있게해준다.
        
        // ● for 가장 기본적인 반복문이며, 특정 조건에 변화를 주어가면서 조건이 맞다면 계속 반복되게 한다.
        let testNum = 5;
        
        // for 문 작성 규칙은 (초기 구문; 조건 구문; 변화 구만)
        for (var i = 1; i <= testNum; i++){ // i(1)이 testNum(5)보다 작을거나 같다면 0부터 +1씩 증감하면서 반복
            cLog(i); // 1,2,3,4,5
        }
        for (var i = 10; i > testNum; i--){ // i(10)이 testNum(5)보다 크다면 10부터 -1씩 차감하면서 반복
            cLog(i); // 10,9,8,7,6
        }
        
        // array와 for 함께 사용
        let firstNames = ['kim', 'lee', 'han']
        
        for (var i = 0; i < firstNames.length; i++){
            cLog(firstNames[i]); // kim, lee, han 각 배열의 원소를 하나하나 출력
        }
        
        // ● while 특정 조건이 참이라면 계속해서 반복하는 반복문
        let idx = 1;
        
        // 무한으로 반복되지 않게 false가 되도록 신경써야한다.
        while (idx <= 10){
            cLog(idx); // 1 ~ 10까지 숫자 하나 씩 출력
            idx++;
        }
        
        // ● for...of 배열을 위한 반복문
        let numbers = [10, 20, 30, 40, 50];
        
        for (let n of numbers){
            cLog(n);
        }
        
        // ● for...in 객체를 위한 반복문
        let doggy = {
            name : '흰둥이',
            color : '흰색',
            age : 2
        } 
        
        cLog(Object.entries(doggy)); // doggy 배열 [[key, value], [key, value]...] 형태로 전체 반환
        cLog(Object.keys(doggy)); // doggy 배열 [key, key...] 형태로 전체 반환
        cLog(Object.values(doggy)); // doggy 배열 [value, value...] 형태로 전체 반환
        
        for (let keys in doggy){
            // array(doggy)에 key 항목을 keys 담고 array(doggy)에 keys에 담기 key 값을 찾아 value 출력
            cLog(keys + ' : ' + doggy[keys]);
        }
        
        // ● break 와 continue
        for (let i = 1; i <= 10; i++){
            if(i === 2) continue; // // 두번째도 반복문이 돌아야하나, i(1씩 증감)가 2 됐을 때 console 출력을 안하고 3으로 바로 넘어감
            cLog(i);
            if(i === 8) break; // 10까지 반복문이 돌아야하나, i(1씩 증감)가 8이 됐을 때 최종적으로 반복문 종료
        }
        
        // 예제1) 배열을 파라미터(매개변수)로 넘겨 받아 총합을 구해보자
        const arrayFn = (num) => {
            let total = 0;
            for (i = 0; i < num.length; i++){
                total += num[i];
            }
            return total
        }
        
        cLog(arrayFn([1,2,3,4,5])); // 15
        
        // 예제2) 숫자로 이루어진 배열이 주어졌을 때, 해당 숫자 배열안에 들어있는 숫자 중 3보다 큰 숫자로만 이루어진 배열을 새로 만들어서 반환해보세요.
        function biggerThanThree(arrNumbers) {
            let newArray = [];
            for (let i = 0; i < arrNumbers.length; i++){
                if(arrNumbers[i] > 3) newArray.push(arrNumbers[i]);
                // 또는
                // if(arrNumbers[i] <= 3) continue; 
                // newArray.push(arrNumbers[i]);
            }
            return newArray;
        }
        
        const arrNumbers = [1, 2, 3, 4, 5, 6, 7];
        cLog(biggerThanThree(arrNumbers)); // 4, 5, 6, 7
        
        cLog(
            '%c ○ [9. 배열 내장함수] * ========================================= ',
            'width: 900px; padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* [9. 배열 내장함수] */
        // 배열을 다룰 때 알고 있으면 너무나 유용한 내장 함수들.
        
        // ● forEach 가장 쉬운 배열 내장함수. for문을 대체가능.
        const hero = ['아이언맨', '캡틴', '토르', '헐크'];
        
        hero.forEach(list => { // 파라미터(매개변수) list라고 명의 후 값을 넘긴다. 함수형태의 파라미터를 전달하는 것을 콜백함수라고 한다. 
            cLog(list); // 아이언맨, 캡틴, 토르, 헐크
        });
        
        const heroInfo = [
            {name : '아이언맨', grade : 'S+'},
            {name : '캡틴', grade : 'S'},
            {name : '토르', grade : 'A+'},
            {name : '헐크', grade : 'A'}
        ];
        
        heroInfo.forEach(list => {
            cLog(`활동명 : ${list.name} / 등급 : ${list.grade}`);
        });
        
        // ● map 배열 안의 각 원소를 변환 할 때 사용. 이 과정에서 새로운 배열이 만들어진다.
        const baseArr = [1,2,3,4,5];
        const baseSquared = [];
        for(let i = 0; i < baseArr.length; i++){
            baseSquared.push(baseArr[i] * 2);
        }
        cLog(baseSquared); // 2, 4, 6, 8, 10
        
        const forSquared = [];
        baseArr.forEach(n => {
            forSquared.push(n * 2);
        });
        cLog(forSquared); // 2, 4, 6, 8, 10
        
        const square = n => n * n; // map의 파라미터(매개변수) square와 같은 애들을 변화함수라고 부른다.
        // cLog(baseArr.map(square)); 
        cLog(baseArr.map(n => n * n)); // 1, 4, 9, 16, 25
        
        // ● indexOf 는 원하는 항목이 몇번쨰인지 찾아준다.
        cLog(hero.indexOf('헐크')); // 3
        
        // ● findIndex 값이 객체이거나 배열이라면 사용.
        const todos = [
            {
                id: 1,
                text: '자바스크립트 입문',
                done: true
            },
            {
                id: 2,
                text: '함수 배우기',
                done: true
            },
            {
                id: 3,
                text: '객체와 배열 배우기',
                done: true
            },
            {
                id: 4,
                text: '배열 내장함수 배우기',
                done: false
            }
        ];
        
        // todos를 todo로 넘겨준다.
        cLog(todos.findIndex(todo => todo.id === 1)); // todo id의 값 1을 가진 객체의 순번 - 0
        cLog(todos.findIndex(todo => todo.done === false)); // todo done의 불리언 값 false를 가진 객체의 순번 - 3
        
        // ● find 함수는 findIndex랑 비슷하나, 찾아낸 값이 몇번째 인지 알애는 것이 아닌, 찾아낸 값 자체를 반환.
        cLog(todos.find(todo => todo.id === 1)); // todo id의 값 1을 가진 값 자체 출력
        
        // ● filter 함수는 배열에서 특정 조건을 만족하는 값들만 따로 추출하여 새로운 배열 생성.
        // fileter 파라미터에는 조건을 넣어주며, 파라미터로 각 원소의 값을 받아온다.
        cLog(todos.filter(todo => todo.done)); // true
        cLog(todos.filter(todo => !todo.done)); // false
        
        // ● splice 는 배열에서 특정 항목을 제거할 때 사용.
        const numberList = [10, 20, 30, 40, 50]; // 배열
        const numIdx = numberList.indexOf(20); // 지우고자 하는 항목의 index 찾기
        // 첫번째 파라미터 : 내가 지우고자 하는 index, 두번째 파라미터 : 해당 index부터 몇개를 지울 것인지 명시
        // 아무것도 입력하지 않을 경우 해당 index 부터 다 지움
        numberList.splice(numIdx, 1); 
        cLog(numberList); // [10, 30, 40, 50]
        
        // ● slice 는 위 splice와 조금 비슷하나, 배열을 잘라낼 때 유용하며 기존 배열은 건들지 않는다.
        const numberList2 = [10, 20, 30, 40, 50]; // 배열
        cLog(numberList2.slice(0, 2)); // [10, 20]
        cLog(numberList2); // [10, 20, 30, 40, 50]
        
        // ● shift 와 pop는 서로 비슷하지만 다르다. 
        // shift는 첫번째 원소를 배열에서 추출하며 배열형태로 반환하지 않는다.
        const numberList3 = [1, 2, 3, 4, 5];
        cLog(numberList3.shift()); // 1
        cLog(numberList3); // shift로 첫번째 원소가 추출되어 [2, 3, 4, 5]
        
        // pop는 마지막 원소를 배열에서 추출하며 배열형태로 반환하지 않는다.
        // 설명을 덫붙이자면, push와 반대 성격을 띄우고 있다. push는 마지막에 추가, pop는 마지막 항목 추출
        const numberList4 = [1, 2, 3, 4, 5];
        cLog(numberList4.pop()); // 5
        cLog(numberList4); // shift로 첫번째 원소가 추출되어 [1, 2, 3, 4]
        
        // ● unshift 는 shift의 반대이다. 배열의 맨 앞에 원소 추가
        const ap = ['a', 'b', 'c'];
        ap.unshift('z'); 
        cLog(ap); // ['z', 'a', 'b', 'c']
        
        // ● concat 은 여러개의 배열을 하나로 합쳐준다.
        const con_arr01 = [1, 2, 3];
        const con_arr02 = [4, 5, 6];
        // concat 함수는 배열을 합칠 때 변화를 주지 않는다.
        cLog(con_arr01.concat(con_arr02)); // [1, 2, 3, 4, 5, 6]
        
        // ● join 은 배열 안의 원소 값들을 문자열 형태로 합쳐준다. 
        const join_arr = [1, 2, 3, 4];
        cLog(join_arr.join()); // 1,2,3,4
        cLog(join_arr.join(' ')); // 1 2 3 4
        cLog(join_arr.join(', ')); // 1, 2, 3, 4
        
        // ● reduce 함수는 배열에 대하여 총 합을 구해야 할 때 매우 유용하다.
        const reduceArr = [1, 2, 3, 4, 5];
        /* forEach 를 이용한 배열의 총합 구하기
        reduceArr.forEach(num => {
          total += num;
        });
        cLog(total); // 15;
        */ 
        // reduce 를 이용한 배열의 총합 구하기
        // reduc의 a,b 피라미터 값, 두번째 파라미터 값은 reduce함수에서 사용할 초기값
        // a는 초기 세팅 값 또는 a + b 한 값
        // total = reduceArr.reduce((a, b) => a + b, 0)
        let total = reduceArr.reduce((a, b) => {
            return a + b;
        }, 0);
        cLog('reduce : ' + total); // 15
        
        // a : 초기값(이후부터는 b를 더한 값)
        // b : 더하려는 값
        // c : 순번
        // d : 배열
        let total2 = reduceArr.reduce((a, b, c, d) => {
            if (c === reduceArr.length - 1){
              return (a + b) / reduceArr.length;
            }
            return a + b;
        }, 0);
        cLog('reduce 평균 값 : ' + total2); // 3
        
        // 배열 및 내장함수 예제 01)
        function countBiggerThanTen(numbers) {
            /* 구현해보세요 */
            // 방법 1
            // let arr = [];
            // for (var i = 0; i < numbers.length; i++){
            //     if (numbers[i] > 10){
            //         arr.push(numbers[i]);
            //     }
            // }
            // return arr.length;
        
            // 방법 2
            // let cnt = 0;
            // numbers.forEach(n => {
            //     if (n > 10){
            //         cnt++;
            //     }
            // });
            // return cnt;
        
            // 방법 3
            // return numbers.reduce((a, b) => {
            //     if (b > 10){ // 각 원소가 10보다 클 경우
            //         return a + 1; // 해당 기준에 + 1 (0 + 1...) 반복 할 수록 1 + 1, 2 + 1.. 
            //     }else{
            //         return a; // 0
            //     }
            // }, 0); // 시작 기준
        
            // 방법 4
            return numbers.filter(n => n > 10).length;
        }
        
        const count = countBiggerThanTen([1, 2, 3, 5, 10, 20, 30, 40, 50, 60]);
        console.log(count); // 5
        
        cLog(
            '%c ○ [10. 프로토타입과 클래스] * ========================================= ',
            'width: 900px; padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* [10. 프로토타입과 클래스] */
        // 프로토타입과 클래스에 대해 알아보기 전 객체 생성자라는 것을 알아보자.
        
        // ● 객체생성자
        // 객체 생성자는 함수를 통해 새로운 객체를 만들고 그 안에 넣고 싶은 값 혹은 함수들을 구현 할 수 있게해준다.
        // 객체 생성자는 사용 할 때는 보통 함수의 이름 시작을 대문자로 시작하고 새로운 객체를 만들 때에는 new 키워드를 앞에 붙여줘야 한다.
        function Animal(type, name, size){
            this.type = type,
            this.name = name;
            this.size = size;
            this.info = function() {
                console.log(`${this.type} - ${this.name} - ${this.size}`);
            };
        };
        
        const dogInfo = new Animal('강아지', '흰둥이', '소형'); // 파라미터를 이용하여 객체(인스턴스)를 만들어주면 된다.
        const catInfo = new Animal('고양이', '초코칩', '소형');
        
        // dogInfo와 catInfo이 함수(info)가 같은데도 불구하고 객체가 생서될 때 마다 함수도 새로 만들어져서 this.info로 설정되고 있다.
        // 같은 객체 생성자 함수를 사용하는 경우, 특정 함수 또는 값을 재사용 할 수 있는데 이게 바로 프로토타입이다.
        dogInfo.info(); // 강아지 - 흰둥이 - 소형
        catInfo.info(); // 고양이 - 초코칩 - 소형
        
        // ● 프로토타입 - 프로토타입은 다음과 같이 객체 생성자 함수 아래에 .prototype.[원하는키] = [코드] 를 입력하여 설정 할 수 있다.
        function Human(team, type, name, height){
            this.team = team,
            this.type = type,
            this.name = name;
            this.height = height;
        };
        
        const son = new Human('토트넘', '공격수', '손흥민', '183cm');
        const kim = new Human('나폴리', '수비수', '김민재', '190cm');
        
        Human.prototype.info = function(){
            console.log(this.name);
        };
        Human.prototype.backNum = (n) => {
            console.log(`등번호 ${n}`);
        }
        Human.prototype.grade = `월드클래스`;
        
        son.info(); // 손흥민
        kim.info(); // 김민재
        
        son.backNum(7); // 등번호 7
        kim.backNum(13); // 등번호 13
        
        console.log(son.grade); // 월드클래스
        console.log(kim.grade); // 월드클래스
        
        // ● 객체 생성자 상속받기
        /*[ SETP 3 ]*/ function Human02(teamBe, teamAf, name){ // Human02.call로 전달받은 파라미터
            this.teamBefore = teamBe,
            this.teamAfter = teamAf,
            this.name = name;
            // Human02.call 로 넘겨받은 파라미터 값 history로 호출
        };
        
        /*[ SETP 4 ]*/ Human02.prototype.history = function(){
            console.log(`${this.name} : ${this.teamBefore} -> ${this.teamAfter} 이적`); // 최종 출력
        }
        
        /*[ SETP 1 ]*/ function Son02(before, after, name){ // Son02(새로운함수)의 인자 값 -> 파라미터
            Human02.call(this, before, after, name); // 받아온 인자 값 -> Human02(객체 생성자) 파라미터 전달
        }
        /*[ SETP 1 ]*/ function Kim02(before, after, name){
            Human02.call(this, before, after, name);
        }
        
        /*[ SETP 2 ]*/ Son02.prototype = Human02.prototype; // prototype을 공유해야 하기 때문에 상속받은 객체 생성자 함수를 만돌고 prototype 값 설정
        /*[ SETP 2 ]*/ Kim02.prototype = Human02.prototype;
        
        /*[ SETP 0 ]*/ const sonInfo = new Son02('레버쿠젠', '토트넘', '손흥민'); // Son02(새로운함수) 생성 및 인자 값 전달
        /*[ SETP 0 ]*/ const kimInfo = new Kim02('페네르바체', '나폴리', '김민재');
        
        sonInfo.history(); // 손흥민 : 레버쿠젠 -> 토트넘 이적
        kimInfo.history(); // 김민재 : 페네르바체 -> 나폴리 이적
        
        // ● 클래스
        // 클래스라는 기능은 C++, Java, C#, PHP 등의 다른 프로그래밍 언어에는 있는 기능인데 
        // 자바스크립트에는 없었기 때문에 예전 자바스크립트 (ES5) 에서는 클래스 문법이 따로 없었기 때문에 
        // 위에서 작성한 코드처럼 객체 생성자 함수를 사용하여 비슷한 작업을 구현해왔습니다.
        
        // ES6 에서부터는 class 라는 문법이 추가되었는데요, 우리가 객체 생성자로 구현했던 코드를 조금 더 명확하고, 
        // 깔끔하게 구현 할 수 있게 해줍니다. 추가적으로, 상속도 훨씬 쉽게 해줄 수 있습니다.
        
        // result 라는 함수를 클래스 내부에 선언했는데, 클래스 내부의 함수를 '메서드'라고 부른다.
        // 이렇게 메서드를 만들면 자동으로 prototype으로 등록된다.
        class Team {
            constructor(league){
                this.league = league;
            }
            result(){ // prototype
                let contry = '';
                switch (this.league){
                    case '프리미어리그' : 
                        contry = '영국';
                        break;
                    case '라리가' : 
                        contry = '스페인';
                        break;
                    case '분데스리가' : 
                        contry = '독일';
                        break;
                    default : 
                        return console.log(`"${this.league}"의 정보를 알 수 없습니다.`);
                        break;
                }
                if( contry.length > 1 ){
                    console.log(`"${this.league}"은(는) ${contry}의 1부 리그 입니다.`);
                }
            }
        };
        
        const leagueType01 = new Team('프리미어리그').result(); // 프리미어리그 은(는) 영국의 1부 리그 입니다.
        const leagueType02 = new Team('분데스리가').result(); // 분데스리가 은(는) 독일의 1부 리그 입니다.
        const leagueType03 = new Team('케이리그').result(); // 케이리그의 정보를 알 수 없습니다.
        
        // 클래스를 사용할 경우 다른 클래스를 쉽게 상속 할 수 있다.
        class TeamSort {
          // constructor 함수란 객체의 초기 값을 지정하기 위해 객체가 생성될 때 실행되기로 약속된 함수
          // constructor 함수를 이용하여 객체의 초기 값을 설정 할 수 있으며, Java Script는 개체를 생성할때 자동으로 constructor함수를 자동으로 호출한다.
          // console.log 를 이용하여 Object.prototype을 보면 값으로 린턴된 객체에는 constructor라는 속성이 들어있다. 이는 서로가 서로의 정보를 가지고 있다.
            constructor(name, team){
                this.name = name;
                this.team = team;
            }
            sort(){ // prototype
                let league = '';
                let contry = '';
                switch (this.team){
                    case '토트넘' : 
                        contry = '영국';
                        league = '프리미어리그';
                        break;
                    case '레버쿠젠' : 
                        contry = '독일';
                        league = '분데스리가';
                        break;
                    case '나폴리' : 
                        contry = '이탈리아';
                        league = '세리에';
                        break;
                    default : 
                        return console.log(`${this.name}의 "${this.team}"은(는) 정보가 없습니다.`);
                        break;
                }
                if( contry.length > 1 && league.length > 1 ){
                    console.log(`${this.name}의 "${this.team}"은(는) "${contry}"의 "${league}" 소속입니다.`);
                }
            }
        };
        
        class Shm extends TeamSort { // ※ 클래스의 자식 클래스 생성 (TeamSort의 Shm은 자식 클래스)
            constructor(team){
                super('손흥민', team); // ※ 부모 생성자 호출
            }
        }
        class Kmj extends TeamSort {
            constructor(team){
                super('김민재', team);
            }
        }
        
        const sonTeam = new Shm('토트넘').sort(); // 손흥민의 "토트넘"은(는) "영국"의 "프리미어리그" 소속입니다.
        const sonTeam2 = new Shm('레버쿠젠').sort(); // 손흥민의 "레버쿠젠"은(는) "독일"의 "분데스리가" 소속입니다.
        const sonTeam3 = new Shm('레알마드리드').sort(); // 손흥민의 "레알마드리드"은(는) 정보가 없습니다.
        const kimTeam = new Kmj('나폴리').sort(); // 김민재의 "나폴리"은(는) "이탈리아"의 "세리에" 소속입니다.
        const kimTeam2 = new Kmj('리버풀').sort(); // 김민재의 "리버풀"은(는) 정보가 없습니다.
        
        // 클래스 예제 01)
        class Food {
            constructor(name) {
                this.name = name; // 
                this.brands = []; // 피자브랜드 명 누적
            }
            addBrand(brand) {
                this.brands.push(brand)
            }
            print() {
                console.log(`--- ${this.name}을/를 파는 음식점들: ---`)
                console.log(this.brands.join(', ')); // join은 배열의 원소를 문자열로 출력한다. 
            }
        }
        
        const pizza = new Food('피자'); // pizza라는 객체 생성
        pizza.addBrand('피자헛'); // pizza라는 객체에 addbrand 함수를 호출하고, this.brands 배열에 push 되어 값 누적되며 출력
        pizza.addBrand('도미노 피자'); // 이하 동문
        
        const chicken = new Food('치킨');
        chicken.addBrand('굽네치킨');
        chicken.addBrand('BBQ');
        
        pizza.print() // 출력
        chicken.print();
        
        
        // 클래스 예제 02)
        class FoodSort {
            constructor(name){
                this.name = name;
                this.brand = [];
            }
            set SetFood(obj){
                this.brand.push(obj);
                this.arr = this.brand;
            };
            get GetFood(){
                console.log(`'${this.name}'을(를) 파는 브랜드는 '${this.arr}'이(가) 있습니다.`);
            }
        }
        
        const ham = new FoodSort('햄버거');
        ham.SetFood = '버거킹';
        
        const coffee = new FoodSort('커피');
        coffee.SetFood = '스타벅스';
        
        ham.SetFood = '맥도날드';
        ham.GetFood;
        
        coffee.SetFood = '메가커피';
        coffee.GetFood;
        

        cLog(
            '%c ○ [2. 알고 있으면 유용한 자바스크립트] ============================ ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        cLog(
            '%c ○ [1. 삼항 연산자] ============================ ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* 1. 삼항 연산자 */ 
        
        // ● 삼항 연산자(문법) - 이 문법은 ES6 문법은 아니다.
        // 아래는 기본 if문법
        // const array_t = [];
        // let array_txt = '';
        // if (array_t.length === 0){
        //     array_txt = '배열이 비어있습니다.';
        // }else{
        //     array_txt = '배열이 비어있지 않습니다.';
        // }
        // console.log(array_txt);
        
        // 아래는 삼항 연산자(조건 ? true : false)
        const array_t = [];
        let array_txt = array_t.length === 0 ? '배열이 비어있습니다.' : '배열이 비어있지 않습니다.';
        console.log(array_txt);
        
        
        // 라인이 너무 길어질경우 다음과 같이 작성이 가능
        const array_t02 = [1,2];
        let array_txt02 = array_t02.length === 0
            ? '(작성법2 테스트)배열이 비어있습니다.' 
            : '(작성법2 테스트)배열이 비어있지 않습니다.';
        console.log(array_txt02);
        
        // 중첩해서 사용도 가능하다.
        const condition1 = false;
        const condition2 = false;
        
        const valued = condition1  
            ? '와우!'           // condition1이 true 일때
            : condition2        // condition1이 false 일때 
                ? 'blabla'      // condition2가 true 일때
                : 'foo';        // condition2가 false 일때
        
        // condition1이 false이기 때문에 condition2 조건 체크, condition2이 false이기 때문에 최종적으로 foo 출력
        console.log(valued); // foo
        
        cLog(
            '%c ○ [2. Truthy and Falsy] ============================ ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* 2. Truthy and Falsy */
        // Java Script 문법까지는 아니지만, 알아둬야 하는 개념이다.
        // Truthy가 true, Falsy가 false 같은 개념
        
        // 다음과 같은 함수가 있다고 가정
        // 그러나 print_t 함수에 파라미터가 비어진 채 실행 될 경우 에러가 발생한다.
        // function print_t(per_info){ // 파라미터 값을 받아온다
        //     console.log(per_info.name);    
        // }
        // const person_t = {
        //     name : 'Han'
        // }
        // print_t(person_t); // Han 출력
        // print_t(); // 파라미터값을 넘겨주지 않을 경우 에러 발생!
        
        // 아래와 같이 바꿔줄 수 있다.
        function print_t(per_info){
            if (!per_info){ // !(NOT)연산자는 부정 및 반대되는 상태
                console.log('파라미터 값이 없거나 값이 잘못된 값 입니다.');
                return
            }
            console.log(per_info.name);    
        }
        const person_t = {
            name : 'Han'
        }
        // print_t(person_t); // Han 출력
        print_t(); // Han 출력
        
        // true and false
        function comp(obj){
            let state;
            obj ? state = true : state = false;
            console.log(`${obj}의 값은 ${state}입니다.`);
        }
        const comp01 = comp(!undefined); // true
        const comp02 = comp(!null); // true
        const comp03 = comp(!0); // true
        const comp04 = comp(!''); // true
        const comp05 = comp(!NaN); // true
        
        const test06 = comp(!3); // false
        const test07 = comp(!'Hello World'); // false
        const test08 = comp(!['1', '2']); // false
        const test09 = comp(![]); // false
        const test10 = comp(!{key : value}); // false
        
        const test11 = comp(true); // true
        const test12 = comp(!true); // false
        const test13 = comp(false); // false
        const test14 = comp(!false); // true
        
        cLog(
            '%c ○ [3. 단축 평가(short-circuit evaluation) 논리 계산법] ============ ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* 3. 단축 평가(short-circuit evaluation) 논리 계산법 */
        /* && 또는 || 연산자로 코드 단축하기 */
        // 일전에 배웠던 논리연산자 예)
        // true && true // true
        // true && false // false
        // true || false // true
        // false || true // true
        
        const changhee = {
            name : 'Chang Hee'
        }
        function fullName(last){
            // if (last){
            //     return `Han ${last.name}`; 
            // }
            // return undefined; 
            
            // && 연산자로 작성문법
            // A && B 사용하게 될 경우 A가 true한 값이면 B
            // A가 false한 값이면 결과는 A 값이다. B까지 도달하지 않는다.
            // return last && last.name;
        
            const state = last && last.name
            // || 연산자로 작성문법
            // A 값이 true한 값이라면 값은 A, A가 false한 값이면 값은 B
            return state || '파라미터 값을 알 수 없습니다.';
        }
        
        // console.log(fullName()); // 에러
        // console.log(fullName(changhee)); // Han Chang Hee
        console.log(fullName()); // 파라미터 값을 알 수 없습니다.
        
        
        console.log(true && 'hello'); // hello - 처음오는 값이 true
        console.log(false && 'hello'); // false - 처음 오는 값이 false 
        console.log('hello' && 'bye'); // bye - 처음 오는 값이 true
        console.log(null && 'hello'); // null - 처음 오는 값이 false 
        console.log(undefined && 'hello'); // undefined - 처음 오는 값이 false 
        console.log('' && 'hello'); // '' - 처음 오는 값이 false 
        console.log(0 && 'hello'); // 0 - 처음 오는 값이 false 
        console.log(1 && 'hello'); // hello - 처음 오는 값이 true 
        console.log(1 && 1); // 1 - 처음 오는 값이 true 
        
        cLog(
            '%c ○ [4. 함수의 기본 파라미터] ============================ ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* 4. 함수의 기본 파라미터 */
        // 함수의 기본 파라미터를 설정하는 방법
        // 예제 01) 원의 넓이를 구하는 함수를 만들어보자
        function calculateCircle(r){
            const radius = r || 1;
            return Math.PI * radius * radius;
        }
        console.log(calculateCircle()); // 3.14...........
        
        // 예제 02) ES6 더 간결하게 작성해보자
        function calculateCircle2(r = 1){
            return Math.PI * r * r;
        }
        console.log(calculateCircle2()); // 3.14...........
        
        // 예제 03) 더 깔끔하게 작성해보자
        const calculateCircle3 = (r = 1) => Math.PI * r * r;
        console.log(calculateCircle3(2)); // 12.56...........
        
        cLog(
            '%c ○ [5. 조건문 더 스마트하게 작성하기] ============================ ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* 5. 조건문 더 스마트하게 작성하기 */
        // 특정 값이 여러 값 중 하나인지 확인해야 할 경우
        function return01(text){
            return text === '고양이' || text === '개';
        }
        console.log(return01('뱀')); // false
        console.log(return01('고양이')); // true
        
        // 배열을 이용하여 좀 더 간결하게 작성해보자
        function return02(text){
            let animalArr = ['고양이', '개'];
            return animalArr.includes(text);;
        }
        console.log(return02('뱀')); // false
        console.log(return02('고양이')); // true
        
        // 화살표 함수로 작성하여 좀 더 더 간결하게 작성해보자
        const return03 = (text) => ['고양이', '개'].includes(text);
        console.log(return03('뱀')); // false
        console.log(return03('고양이')); // true
        
        // 코드가 짧다고 해서 무조건 좋은건 아니다. 단 코드가 짧으면서도 읽었을 때 어떤 역할을 하는지 잘 이해가 되어야 좋은 코드다
        
        // 값에 따라 다른 결과물을 반환해야 할때
        // switch문 사용할때 return을 해준다면 break는 생략해도 된다.
        function getSound(type){
            switch (type) {
                case '개' :
                    return '멍멍!';
                case '고양이' :
                    return '야옹!';
                default :
                    return '..?';
            }
        }
        console.log(getSound()); // ..?
        console.log(getSound('개')); // 멍멍!
        
        // 객체를 이용하여 위 switch 문보다 더 깔끔하게 작성해보자
        function getSound02(type){
            const sounds = {
                개 : '멍멍멍',
                고양이 : '야옹'
            }
            return sounds[type] || '...?';
        }
        console.log(getSound02()); // ...?
        console.log(getSound02('개')); // 멍멍멍!
        
        // 각 조건마다 실행되는 구문이 다를 경우 함수 호출을 이용하여 작성해보자
        // 객체 안에 각각 개와 고양이라는 함수를 담아두고 파라미터로 받아온 값을 sounds[type]() 접근하여 실행
        function getSound03(type){
            const sounds = {
                개(){
                    console.log('멍멍멍멍멍멍');
                    console.log('메롱');
                },
                고양이(){
                    console.log('야옹야옹야옹');
                }
            }
            if (!sounds[type]){
                console.log('......?');
                return
            }
             
            sounds[type]();
        }
        getSound03(); // ......?
        getSound03('개'); // 멍멍멍멍멍멍!
        
        cLog(
            '%c ○ [6. 비구조화 할당(구조 분해)문법] ============================ ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* 6. 비구조화 할당(구조 분해)문법 */
        // 비구조 할당 : 객체 안에 있는 값을 추출해서 변수 혹은 상수로 바로 선언
        const object = {a : 1, b: 2};
        const {a, b} = object; // object라는 객체의 a,b 값이 상수 a,b에 바로 선언 - 할당 받을 때 명과 동일해야한다.
        console.log(`비구조 할당 : object의 a 값이 상수 a에 a값 ${a} 바로 선언`); // 1
        console.log(`비구조 할당 : object의 a 값이 상수 b에 b값 ${b} 바로 선언`); // 2
        
        // 함수의 파라미터에 비구조 할당도 가능하다.
        const object02 = {a : 1, b: 2};
        function printObj ({a, b}){
            console.log(`비구조 할당 : object의 a 값이 파라미터 a에 a값 ${a} 바로 선언`); // 1
            console.log(`비구조 할당 : object의 a 값이 파라미터 b에 b값 ${b} 바로 선언`); // 2
        }
        printObj(object02);
        
        // b의 값이 주어지지 않았을 경우
        const object03 = {a : 1};
        function printObj02 ({a, b}){
            console.log(`비구조 할당 : object의 a 값이 파라미터 a에 a값 ${a} 바로 선언`); // 1
            console.log(`비구조 할당 : object의 a 값이 파라미터 b에 b값 ${b} 바로 선언`); // undefined
        }
        printObj02(object03);
        
        // 비구조화 할당 시 기본값 설정
        const object04 = {a : 1};
        function printObj03 ({a, b = 2}){ // b의 기본값 2 할당
            console.log(`비구조 할당 : object의 a 값이 파라미터 a에 a값 ${a} 바로 선언`); // 1
            console.log(`비구조 할당 : object의 a 값이 파라미터 b에 b값 ${b} 바로 선언`); // 2
        }
        printObj03(object04);
        
        // 비구조화 할당 시 기본값 설정 예제 2)
        const object05 = {a2 : 1};
        const {a2, b2 = 2} = object05; // 할당을 받을 때에는 할당 받는 값의 key명과 동일해야한다.
        console.log(a2); // 1
        console.log(b2); // 2
        
        // 비구조화 할당시 이름 바꾸기
        const testAnimal = {
            name : '흰둥이',
            tpye : '개'
        }
        
        console.log(testAnimal.name); // 흰둥이
        const { name : nameChange } = testAnimal; // testAnimal라는 객체 안에 name을 nameChange로 선언하겠다.
        console.log(nameChange); // 이름바꿔 선언한 nameChange 출력 (흰둥이)
        
        // 배열 비구조화 할당
        const arrayNum = [1, 2];
        const [one, two] = arrayNum;
        console.log(one, two); // 1, 2
        const [onee] = arrayNum;
        console.log(onee, twoo = 3); // 1, 3 (기본 지정한 값)
        
        // 깊은 값 비구조화 할당
        const deepObject = {
            list : {
                human01 : {
                    name : 'Han Chang Hee',
                    lang : ['Ko', 'En', 'Jp', 'Ch'],
                    car : true
                },
                human02 : {
                    name : 'Kim Hyeon Young',
                    lang : ['Ko', 'En'],
                    car : false
                }
            },
            length : 2
        }
        
        // 깊은 값 추출 방법 1
        const { name : userName, lang : userLanguages, car : userCar } = deepObject.list.human01; // human01의 각 key, val 값 이름 변경 및 비구조 할당
        const { length } = deepObject; // 객체의 length 비구조할당
        console.log(`이름 : ${userName} / 언어 : ${userLanguages} / 차량유무 : ${userCar}`); // 이름 : Han Chang Hee / 언어 : Ko,En,Jp,Ch / 차량유무 : true
        console.log(length); // 2
        
        const informationTotal = { // 각각 key의 이름으로 선언된 값이 있을 경우 대입 매칭
            userName, // userName = userName
            userLanguages, // userLanguages = userLanguages
            userCar, // ...
            length // ...
        };
        console.log(informationTotal); // 객체 {userName: 'Han Chang Hee', userLanguages: Array(4), userCar: true, length: 2}
        
        // 깊은 값 추출 방법 2
        // deepObject에 접근하여 각각 이름 변경 및 비구조 할당 형태
        const {
            list : {
                human02 : { name : userName2, lang : userLanguages2, car : userCar2 }
            },
            langth
        } = deepObject;
        
        const informationTotal2 = {
            userName2,
            userLanguages2,
            userCar2,
            length
        }
        console.log(informationTotal2); // 객체 {userName2: 'Kim Hyeon Young', userLanguages2: Array(2), userCar2: false, length: 2}
        
        
        cLog(
            '%c ○ [7. spread와 rest] ============================ ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* 7. spread와 rest */
        // ES6에서 도입된 spread와 rest 문법에 알아보자. 둘은 서로 완전 다른 문법이지만, 비슷한 부분이 있다.
        
        // spread란 단어가 가지고 있는 의미(펼치다, 퍼트리다) 그대로 spread 문법을 사용하면 객체 혹은 배열을 펼칠 수 있다.
        // 기존의 객체를 건들지않고 새로운 객체를 만들때, 기존의 정보를 그대로 담아 사용이 가능하다.
        const slime = {
            name: '슬라임'
        };
        
        const cuteSlime = {
            ...slime, // spread(...) 연산자
            attribute: 'cute'
        };
        
        const purpleCuteSlime = {
            ...cuteSlime, // spread(...) 연산자
            color: 'purple'
        };
        
        console.log(slime); // {name: '슬라임'}
        console.log(cuteSlime); // {name: '슬라임', attribute: 'cute'}
        console.log(purpleCuteSlime); // {name: '슬라임', attribute: 'cute', color: 'purple'}
        
        // spread(...) 연산자를 이용해 배열
        const aaaanimal = ['개', '고양이', '여우'];
        const aaaanimalNum = [1, 2, 3];
        const anotherAaaanimal = [...aaaanimal, '돌고래']; // spread(...) 연산자를 이용하여 기존의 배열은 건들지 않고 내용을 합친다.
        const aaaanotherAaaanimal = [...aaaanimalNum, ...aaaanimal, '돌고래', ...aaaanimalNum]; // spread(...) 연산자는 여러번 이용 가능하다.
        
        
        console.log(aaaanimal); // ['개', '고양이', '여우']
        console.log(anotherAaaanimal); // ['개', '고양이', '여우', '돌고래']
        console.log(aaaanotherAaaanimal); // [1, 2, 3, '개', '고양이', '여우', '돌고래', 1, 2, 3]
        
        // rest의 생김새는 spread와 비슷하나, 역할!이 매우 다르다
        // rest는 객체, 배열, 함수의 파라미터에서 사용이 가능하다.
        // rest의 예제 1 - 객체에서의 예시
        const purpleCuteSlimeBoss = {
            slime_name : '슬라임',
            slime_type : 'boss',
            slime_attribute : 'cute',
            slime_color: 'purple'
        }
        
        // rest는 객체와 배열에서 사용 할 때는 아래와 같이 비구조화 할당 문법과 함께 사용된다.
        const { slime_color, ...rest} = purpleCuteSlimeBoss;
        console.log(slime_color); // purple
        console.log(rest); // slime_color 제외한 값이 출력 {name: '슬라임', type: 'boss', attribute: 'cute'}
        
        // 추출한 값의 이름을 꼭 rest로 지정할 필요는 없다.
        const { slime_name, ...etc} = purpleCuteSlimeBoss;
        console.log(slime_name); // 슬라임
        console.log(etc); // slime_name 제외한 값 출력 {slime_type: 'boss', slime_attribute: 'cute', slime_color: 'purple'}
        
        // 기존의 객체에 영향을 주지 않는다.
        console.log(purpleCuteSlimeBoss); // {slime_name: '슬라임', slime_type: 'boss', slime_attribute: 'cute', slime_color: 'purple'}
        
        // 배열에서의 rest
        const numberGroup = [0, 1, 2, 3];
        const [_one, ..._etc] = numberGroup;
        console.log(_one); // 0
        console.log(_etc); // 1, 2, 3
        
        // const [...front, _last] = numberGroup; // rest는 앞에 먼저 사용될 수 없다. ERROR
        
        // 함수에서의 rest
        // 함수에서의 rest 예시 - 함수의 파라미터로 넣어준 모든 값들을 합해주는 함수를 만들었다고 가정해보자.
        function sumNum (...rest/*a, b, c, d*/){
            // let total = 0;
            // if(a) total += a;
            // if(b) total += b;
            // if(c) total += c;
            // if(d) total += d;
            // return total;
        
            // rest를 이용하여 파라미터의 값을 배열로 받아온다.
            // 불필요하게 파라미터의 값을 일일이 확인할 필요성이 없어진다.
            return rest.reduce((num, cur) => total = num + cur, 0); // reduce함수는 복습하고 오자. 헷갈리네잉..
        }
        console.log(sumNum(1, 2, 3, 4)); // 10
        console.log(sumNum(1, 2, 3)); // 6
        
        // 함수 인자와 spread        
        // 함수 인자와 spread 설명 전 파라미터와 인자의 차이점 알고가자!!!!!!!!!!!
        const myFunction = (text) => { // 여기서 txt는 파라미터 - 함수에서 값을 읽을 때 그 값을 파라미터
            console.log(text); // 여기서 txt는 인자
        }
        myFunction('Hello World') // 여기서 'Hello World'는 인자 - 함수에서 값을 부여할때 그 값을은 인자

        // 함수 인자와 spread 예제1 - 함수 파라미터 rest 사용한 것과 비슷하나 반대의 역할이다.
        // 배열 안에 있는 원소들을 모두 파라미터로 넣어주고 싶다고 사정해보자
        // function sum(...rest) { // 실행된 sum 
        //     return rest.reduce((acc, current) => acc + current, 0);
        // }

        // const numberss = [1, 2, 3, 4, 5, 6];
        // const result = sum( // numberss배열의 각 값을 sum 함수의 인자 값으로 넘겨주고 sum 실행
        //     numberss[0], // numberss배열의 0번 째 값 1
        //     numberss[1], // numberss배열의 1번 째 값 2
        //     numberss[2], // numberss배열의 2번 째 값 3
        //     numberss[3], // numberss배열의 3번 째 값 4
        //     numberss[4], // numberss배열의 4번 째 값 5
        //     numberss[5]  // numberss배열의 5번 째 값 6
        // );
        // console.log(result); // 21

        function totalNumList(...rest){ // rest 사용
            rest.reduce((a, b) => testScope = a + b, 0);
            return testScope;
        }
        const arrayList = [1, 2, 3, 4, 5, 6];
        console.log(totalNumList(...arrayList)); // spread 사용 - 21

        function max(...adTest) {
            return adTest.reduce(
                // initialValue값 없기 때문에 acc : 1, current : 2
                //             …             acc : 2, current : 3
                //             …             acc : 3, current : 4
                //             …             acc : 4, current : 10
                //             …             acc : 10, current : 5
                (acc, current) => (current > acc ? current : acc)
                // (accumulator, currentValue) => (currentValue > accumulator ? currentValue : accumulator), initialValue
                // aac : 누산기는 콜백의 반환값을 누적한다. 
                // (initialValue값을 설정하지 않았기 때문에, accumulator의 값은 배열의 첫번째 값과 같다)
                // current : 처리할 현재 요소 
                // (initialValue값을 설정하지 않았기 때문에, currentValue의 값은 배열의 두번째 값과 같다)
            );
        }
        const result = max(1, 2, 3, 4, 10, 5, 6, 7); // 10
        console.log('[reduce]를 좀 더 공부를 해야해.. : ' + result);


        cLog(
            '%c ○ [8. scope의 이해] ============================ ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* 8. scope의 이해 */
        // scope란 변수 혹은 함수를 선언했을때 해당 변수 또는 함수가 유효한 범위를 의미한다.
        // scope의 종류는 총 3가지
        // a. Global (전역) Scope : 코드의 모든 범위에서 사용이 가능.
        // b. Function (함수) Scope : 함수 안에서만 사용 가능.
        // c. Block (블럭) Scope : if, for, switch 등 특정 블록 내부에서만 사용 가능.

        // Global (전역) Scope 와 Function (함수) Scope의 예제
        const vvalue = 'hello!'; // Global (전역) Scope로 선언된 값은 어디서든 사용가능

        function myFunction2() {
            console.log('myFunction: ');
            // Global (전역) Scope로 선언된 vvalue 값을 출력
            console.log(vvalue); // hello!
        }

        function otherFunction2() {
            console.log('otherFunction: ');
            // Function (함수) Scope로 선언되어 otherFunction2 내부에서만 사용가능
            const vvalue = 'bye!'; 
            console.log(vvalue); // bye!
        }

        myFunction2(); // 함수실행
        otherFunction2(); // 함수실행

        console.log('global scope: ');
        // otherFunction에서 Function (함수) Scope로 선언되었어도, Global (전역) Scope는 변하지 않음
        console.log(vvalue); // hello!

        // Global (전역) Scope 와 Function (함수) Scope, Block (블럭) Scope 예제
        const vvvalue = 'hello!'; // 전역 선언

        function mmmyFunction() {
            const vvvalue = 'bye!'; // 함수 내 선언
            const anotherVvvalue = 'world'; // 함수 내 선언
            function functionInside() {
                console.log('functionInside: ');
                // mmmyFunction의 하위 함수라 호출 가능
                console.log(vvvalue); // bye!
                // mmmyFunction의 하위 함수라 호출 가능
                console.log(anotherVvvalue); // world
            }
            functionInside();
        }

        mmmyFunction(); // 함수 실행
        console.log('global scope: ');
        console.log(vvvalue); // hello!
        // anotherVvvalue는 mmmyFunction내부에 선언된 함수 선언이므로 mmmyFunction외부에서는 호출 불가
        // console.log(anotherVvvalue); // ERROR

        // * Hoisting
        // Hoisting이란 자바스크립트에서 아직 선언되지 않은 함수/변수를 [끌어올려서] 사용 할 수 있는 자바스크립트의 작동 방식을 의미한다.

        // Hoisting 예제 1
        // 아래와 같이 myFunctionTest 함수가 선언되기전 myFunctionTest를 호출 햇는데 정상작동이 된다.
        // myFunctionTest();

        // function myFunctionTest() {
        //     console.log('hello world!');
        // }

        // ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
        // 잘 작동하는 이유는 자바스크립트 엔진이 코드를 해석하는 과정에서 아래와 같이 받아들이기 때문이다.
        function myFunctionTest() {
            console.log('hello world!');
        }

        myFunctionTest();
        // 이러한 현상을 Hoisting이라고 한다.

        // Hoisting 예제 2
        // console.log(hoiNum); ERROR

        // console.log(hoiNum);
        // var hoiNum = 2; // undefined

        // ↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓
        // 잘 작동하는 이유는 자바스크립트 엔진이 코드를 해석하는 과정에서 아래와 같이 받아들이기 때문이다.
        var hoiNum;
        console.log(hoiNum); // undefined
        hoiNum = 2
        // 위 Hoisting 예제에서 let 또는 const를 쓰지 않은 이유는 두가지 선언 방식은 hoisting가 발생하지 않고 에러가 발생한다.
        // 다만 Babel 이라는 도구를 이용하면 const와 let을 var로 변환되어 작성이 가능하다.
        // Hoisting은 자바스크립트 언젠이 갖고 있는 성질이며, Hoisting을 일부러 할 피룡는 없지만, 방치하지 않는 것이 좋다.
        // 왜냐하면 Hoisting이 발생하는 코드는 이해하기 어렵고, 유지보수도 힘들지며 의도치 않는 결과물이 나타나기 쉽다.
        // Hoisting을 방지하기 위해서는 함수의 경우 꼭 선언 후 호출하도록 주의하며 ver대신 const, let을 위주로 사용한다.
        // 추가적으로 나중에 자바스크립트 개발을 본격적으로 하게 될 때에는 ESLint 라는 것을 사용하여, Hoisitng이 발생하는 코드는 에디터상에서 쉽게 발견이 가능하다.

        cLog(
            '%c ○ [3. 자바스크립트에서 비동기 처리 다루기] ============================ ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        cLog(
            '%c ○ [1. 비동기 처리 정의] ============================ ',
            'padding: 8px 16px; background-color: #fff; color: #000;'
        );
        /* 1. 비동기 처리와 비동기 처리 방법 */  
        // 만약 작업을 동기적으로 처리한다면 작업이 끝날 때까지 기다리는 동안 중지 상태가 되기 때문에 다른 작업을 할 수 없습니다.
        // 그리고 작업이 끝나야 비로소 그 다음 예정된 작업을 할 수 있다. 하지만 이를 이동기적으로 처리한다면 흐름이 멈추지 않기 때문에 
        // 동시에 여러 가지 작업을 처리 할 수도 있고, 기다리는 과정에서 다른 함수도 호출할 수 있다.
        // 한번코드를 보고 이해보자
        function work(){
            const start = Date.now(); // 현재 시간(자바스크립트의 내장함수)
            for(let i = 0; i < 1000000000; i++){} // 1,000,000,000 번 루프
            const end = Date.now(); // 루프가 다 돌고 나서 현재 시간
            console.log(end - start + 'ms'); // 두 시간의 간극 계산 및 출력
        }
        work(); // work 함수 호출
        console.log('다음 작업');

        // work() 함수가 호출되면 for문이 돌아갈 때는 다른 작업은 처리하지 않고 온전히 for문만 실행하고 있다.
        // 만약 이 작업이 진행되는 동안 다른 작업도 하고 싶다면 함수를 비동기 형태로 전환해주어야 한다.
        // 그렇게 하기위해서는 setTimeout 이라는 함수를 사용해주어야 한다.
        function work2(){
            setTimeout(() => {
                const start = Date.now(); // 현재 시간(자바스크립트의 내장함수)
                for(let i = 0; i < 1000000000; i++){} // 1,000,000,000 번 루프
                const end = Date.now(); // 루프가 다 돌고 나서 현재 시간
                console.log(end - start + 'ms'); // 두 시간의 간극 계산 및 출력
            }, 0)
        }
        console.log('작업 시작');
        work2();
        console.log('다음 작업');
        // setTimeout 함수는 첫번째 파라미터에 넣은 함수를 두번째 파라미터에 넣은 시간(ms단위)이 흐른 후 호출 해줍니다. 
        // 지금은 두번째 파라미터에 0을 넣줬으니, 이 함수는 바로 실행됩니다. 0ms이후에 실행한다는 의미이지만, 실제로는 4ms 이후에 실행된다.
        // setTimeout을 사용하면 우리가 정한 작업이 백그라운드에서 수행되기 때문에 기존의 코드 흐름을 막지 않고 동시에 다른 작업들을 진행하게 할 수 있다.
        // 출력된 결과물을 확인해보면, 작업시작 이후 work2 함수가 호출되어 for문이 돌고 있는 동안, 다음 작업이 출력되고 이후 for문이 끝나고 정상적으로 얼마나 걸렸는지 출력된다.

        // 만약 work라는 함수가 끝난 다음에 어떠한 작업을 처리하고 싶다면 어떻게 해야 할까?
        // 이럴 땐 콜백 함수를 파라미터로 전달해주면 된다. 콜백 함수란, 함수 타입의 값을 파라미터로 넘겨줘, 파라미터로 넘겨받은 함수를 특정 작업이 끝나고 호출해주는 것을 의미한다.
        console.log('---------work3---------');
        function work3(callback){
            setTimeout(() => {
                const start = Date.now();
                for (let i = 0; i < 1000000000; i++){}
                const end = Date.now();
                console.log(end - start + 'ms');
                callback();
            }, 0);
        }

        console.log('작업 시작');
        work3(() => {
            console.log('작업이 끝났습니다');
        });
        console.log('다음 작업');

        // 다음과 같은 작업들은 주로 비동기적으로 처리하게 된다.
        // 1. Ajax Web Api 요청 : 만약 서버쪽에서 데이터를 받아와야 할 때는 요청을 하고 서버에서 응답을 할 때까지 대기를 해야되기 때문에 작업을 비동기적으로 처리
        // 2. 파일 읽기 : 주로 서버쪽에서 파일을 읽어야 하는 상황에서는 비동기적 처리
        // 3. 암호화/복호화 : 암호화/복호화를 할 때에는 바로 처리가 되지 않고, 시간이 어느 정도 걸리는 경우가 있기 떄문에 비동기적으로 처리한다.
        // 4. 작업 예약 : 단순히 어떤 작업을 몇초 후에 스케쥴링 해야하는 상황에는, setTimeout을 사용하여 비동기적으로 처리한다.

        // 비동기 작업을 다룰 때에는 callback 함수 외에도 Promise, 그리고 async/await 라는 문법을 사용하여 처리 할 수 있습니다. 이번 챕터에서는 이에 대하여 알아보게 됩니다.

        /* Promise */
        // 프로미스는 비동기 작업을 조금 더 편하게 처리 할 수 있도록 ES6에 도입된 기능이다.
        // 이전에는 비동기 작업을 처리 할 때에는 콜백 함수로 처리를 해야 했었는데, 콜백 함수로 처리하게되면 비동기 작업이 많이 질 경우 코드가 쉽게 난잡해지게 되었다.

        // callback 비효율 적인 비동기 작업
        // 숫자 n을 파라미터로 받아와, 다섯번에 걸쳐 1초마다 1씩 더해서 출력하는 작업을 setTimeout으로 구현
        function inc(n, callback){
            setTimeout(() => {
                const incNum = n + 1;
                console.log(incNum);
                if (callback){
                    callback(incNum);
                }
            }, 1000);
        }

        inc(0, n => {
            inc(n, n => {
                inc(n, n => {
                    inc(n, n => {
                        inc(n, n => {
                            console.log('끝');
                        });
                    });
                }); 
            });
        });
        // 위와 같이 구현 할 경우 코드 읽기가 복잡하며, 이런 식의 코드를 Callback Hell(콜백지옥)이라고 부른다.

        // 위와같이 비동기적으로 처리를 해야하는 일이 많아 질수록 코드의 깊이가 계속 깊어지는 현상이 있는데, 
        // Promise를 사용하면 이렇게 코드의 깊이가 깊어지는 현상을 방지 할 수 있다.
        // Promise 만들기 첫번째 파라미터는 성공했을 때, 두번째 파라미터는 실패했을 때
        const myPromise = new Promise((resolve, reject) => {
            // 구현 할 코드..
        });
        // Promise는 성공 할 수도 있고, 실패 할 수도 있다. 성공 할 때에는 resolve를 호출해주면 되고, 실패할 경우 reject를 호출해주면 된다.
        // 지금 예제의 경우 실패하는 상황은 고려하지 않고, 1초 뒤에 성공 시키는 상황에 대해서만 구현을 해보자
        const myPromise2 = new Promise((resolve, reject) => {
            setTimeout(() => {
                resolve(1000);
            }, 1000);
        });

        // myPromise2 (1초 후  resolve(1000)을 호출)이 끝난 후 실행
        myPromise2.then(n => { // resolve의 파라미터 값을 n으로 받아온다
            console.log(n); // resolve의 파라미터 값 n 출력
        });

        // Promise 실패 구현해보자 성공할 때는 aa, 실패할 때는 bb
        // 실패하는 상황에서는 bb(reject)을 사용한다
        const myPromise3 = new Promise((aa, bb) => {
            setTimeout(() => {
                bb(new Error()); // reject 값
            }, 1000);
        })

        myPromise3
            .then(nn => { // reject 당하므로 then은 건너뛴다.
                console.log(nn);
                console.log(123123123);
            })
            .catch(error => { // catch를 통해 reject 됐을 때 수행 할 작업을 설정가능하다
                console.log(error);
            });

        // Promise 를 만드는 함수를 작성해보자
        function increaseAndPrint(n) { // increaseAndPrint 이라는 함수생성
            return new Promise((resolve, reject) => { // 생성자 함수 new로 새로 Promise 생성
                setTimeout(() => { // 1초 후 실행
                    const value = n + 1 // n(파라미터)에 1을 더한 값을 value라는 상수 선언
                    // valus 값이 5와 같을 경우 아래 if문!
                    if (value === 5){ 
                        const error = new Error(); // 에러 선언
                        error.name = 'Value is Five Error'; // 선언된 에러의 이름 설정
                        reject(error); // error 출력
                        return;
                    }
                    // valus 값이 5가 아닐 경우 위 if문은 건너뛰고 아래 실행
                    console.log(value); // value 값 호출
                    resolve(value); // 
                }, 1000);
            });
        }
    </script>
</html>