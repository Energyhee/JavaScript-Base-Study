<script>
    console.log('========================시작==========================');
console.log(
  '%c * var / let / const 차이점',
  'padding: 2px; background-color: #fff; color: #000;'
);
/* [var 과 let, const 차이점] */
// ver 과 let의 큰 차이점은 var은 값으 바뀌거나 선언을 하는데 있어 제한이 없다.
// IE10 이하 버전에서는 let, const를 사용할 수 없어 babel과 같은 도구로 구형 브라우저에서도 돌아갈 수 있게끔 변환작업 진행
// 구형 브라우저 호환을 해야한다면, var을 사용하게 될 수도 있다.
// var a = 1;
// var a = 2;
// a = 3;
// console.log('a : ' + a);     // 3

// let은 같은 블럭 내에서 같은 이름으로 선언은 불가, 값 변경 가능
// let b = 1;
// let b = 2;                   // error

// const는 같은 블럭 내에서 같은 이름으로 선언 불가, 값 변경 불가
// const c = 1;
// const c = 1;                 // error
// c = 2;

console.log(
  '%c * 변수와 상수 및 선언',
  'padding: 2px; background-color: #fff; color: #000;'
);
/* [변수와 상수 및 선언] */
let value = 1;
console.log('value :: ' + value); // 1

console.log('%c * 변수', 'padding: 2px; background-color: #fff; color: #000;');
/* [1. 변수 : 바뀔 수 있는 값을 말한다.] */
let value2 = 1;
value2 = 2;
console.log('value2 :: ' + value2); // 2

// 변수를 선언 할 때 주의 점은 같은 이름으로 선언 할 수 없다.
// 단, 다른 블럭 범위 내에서는 가능하다.
// let value3 = 1;
// let value3 = 2;    // ERROR

console.log('%c * 상수', 'padding: 2px; background-color: #fff; color: #000;');
/* [2. 상수 : 한번 선언하고 값이 바뀌지 않는 값을 말한다.] */
// const a = 1;
// a = 2;             // ERROR
// console.log(a);

// 상수를 선언 할 때 주의 점은 같은 이름으로 선언 할 수 없다.
// const a = 1;
// const a = 2;       // ERROR

console.log(
  '%c * 데이터타입',
  'padding: 2px; background-color: #fff; color: #000;'
);
/* [3. 데이터 타입] */
let type01 = 1;
console.log('type01 :: ' + type01 + ' / ' + typeof type01); // 1 'number'
let type02 = 'text';
console.log('type02 :: ' + type02 + ' / ' + typeof type02); // text 'string'
let type03 = 1 + '1';
console.log('type03 :: ' + type03 + ' / ' + typeof type03); // 11 'string'
let type04 = true;
console.log('type04 :: ' + type04 + ' / ' + typeof type04); // true 'boolean'
let type05 = false;
console.log('type05 :: ' + type05 + ' / ' + typeof type05); // false 'boolean'
// null은 '의도적'으로 빈 값을 할당한 상태(빈 객체), 자료형이 있는 상태
let type06 = null;
console.log('type06 :: ' + type06 + ' / ' + typeof type06); // null 'object'
// undefined은 원시값으로 값을 할당하지 않았을 때 자동 할당, 자료형이 없는 상태
let type07;
console.log('type07 :: ' + type07 + ' / ' + typeof type07); // undefined 'undefined'

console.log(
  '%c * 연산자',
  'padding: 2px; background-color: #fff; color: #000;'
);
/* [4. 연산자] */
let example = 1; // 변수 선언
example = 2; // 변수 초기화

// * 산술 연산자 +, -, *, /
let calculation = 1 + 2 / 2;
console.log('calculation ::' + calculation); // 2 'number'
let plus = 1;
let plusType1 = plus++;
// 연산자가 뒤에 붙을 경우 직전 값을 반환한다.
console.log('plus++ :: ' + plusType1); // 1 'number'
console.log('plus++ cont :: ' + plus); // 2
let plusType2 = ++plus;
// 연산자가 앞에 붙을 경우 이후 값을 반환한다.
console.log('++plus :: ' + plusType2); // 3 'number'
console.log('plus-- cont :: ' + plus);

// * 대입 연산자
let number = 2;
number = number + 2;
// 아래와 같이 작성도 가능하다.
// let number = 2;
// number += 2;
// 다른 연산도 가능하다.
// number += 2;
// number -= 2;
// number *= 2;
// number /= 2;
console.log('number :: ' + number); // 4 'number'

// * 논리 연산자 : 논리 연산자는 boolean(불리언) 타입을 위한 연산자 이다
// ! : NOT
// && : AND
// || : OR

// !(NOT) 연산자는 반대 상태로 변경해준다.
const state01 = !true;
console.log('!true :: ' + state01); // false;
const state02 = !false;
console.log('!false :: ' + state02); // true;

// &&(AND) 연산자는 양쪽의 값이 둘다 true 일 때만 true
const ab = true && true;
console.log('true && true :: ' + ab); // true

// ||(OR) 연산자는 양쪽의 값 중 어느 하나라도 맞을 경우 true, 둘 다 false 일 때 false
const abc = false || true;
console.log('false || true :: ' + abc); // true

// 논리 연산자 연산 순서는 !(NOT) > &&(AND) -> ||(OR) 순
const abcd = !((true && false) || (true && false) || !false);
// !((true && false) || (true && false) || true); NOT 연산자 처리
// !(false || false || true); AND 연산자 처리
// !true; 마지막 true 및 NOT 연산자로 인해 false
console.log('!((true && false) || (true && false) || !false) :: ' + abcd); // false

// 비교 연산자
// 비교 연사자는 되도록 등호 세개(===)를 쓸 것 그래야 값의 타입까지 상세 비교를 함으로, 실수 유발이 적어진다.
const left01 = 1;
const right01 = 1;
console.log('1 === 1 :: ' + (left01 === right01)); // true

const left02 = 1; // number
const right02 = '1'; // string
// 등호를 세개만 썼을 경우 해당 값의 type까지 검사한다
console.log('1 === "1" :: ' + (left02 === right02)); // false

const left03 = 1; // number
const right03 = '1'; // string
// 등호를 두개만 썼을 경우 해당 값의 type까지 검사를 하지 않는다.
console.log('1 == "1" :: ' + (left03 == right03)); // true

const left04 = 0; // number
const right04 = false; // object
// 0과 false는 같은 값으로 간주된다.
console.log('0 == false :: ' + (left04 == right04)); // true

const left05 = null; // number
const right05 = undefined; // object
// 0과 false는 같은 값으로 간주된다.
console.log('null == undefined :: ' + (left05 == right05)); // true

// 크고 작음 (부등호)
const num01 = 10;
const num02 = 20;
const num03 = 20;

console.log('10 < 20 : ' + (num01 < num02)); // true
console.log('10 > 20 : ' + (num01 > num02)); // false
console.log('10 <= 20 : ' + (num01 <= num02)); // true
console.log('10 >= 20 : ' + (num01 >= num02)); // false
console.log('20 >= 20 : ' + (num02 >= num02)); // true
console.log('20 < 20 : ' + (num02 < num02)); // false

// 연사자를 이용하여 문자열(string) 합치기도 가능
const text01 = 'Han';
const text02 = 'ChangHee';

console.log(text01 + text02);
console.log(text02 + text01);

console.log(
  '%c * 조건문',
  'padding: 2px; background-color: #fff; color: #000;'
);

console.log('=========================끝===========================');
</script>